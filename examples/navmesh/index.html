<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>NavMesh Demo Game</title>
    <style>
      /* ------ Layout Básico ------ */
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      }
      #gameCanvas {
        background: #1a1a1a
          url('data:image/svg+xml;utf8,<svg width="40" height="40" xmlns="http://www.w3.org/2000/svg"><rect width="40" height="40" fill="%23222222"/><path d="M40 0 L0 0 0 40" fill="none" stroke="%232a2a2a" stroke-width="1"/></svg>');
      }
      #debugCanvas {
        pointer-events: none;
      }

      /* ------ Contêineres fixos ------ */
      #controls,
      #howToPlay,
      #layerLegend,
      #gameStatus {
        position: fixed;
        padding: 10px;
        background: rgba(25, 25, 25, 0.95);
        color: #fff;
        border-radius: 5px;
        z-index: 1000;
      }
      #controls {
        top: 20px;
        left: 20px;
        width: 220px;
      }
      #howToPlay {
        top: 20px;
        right: 20px;
        max-width: 280px;
      }
      #layerLegend {
        bottom: 20px;
        left: 20px;
        min-width: 150px;
      }
      #gameStatus {
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        z-index: 1001;
        font-size: 0.9em;
      }

      /* ------ Modal de Debug ------ */
      .modal {
        display: none;
        position: fixed;
        z-index: 2000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }
      .modal-content {
        background: #fff;
        margin: 10% auto;
        padding: 20px;
        width: 80%;
        max-width: 600px;
        color: #000;
        border-radius: 5px;
      }
      .close {
        float: right;
        font-size: 24px;
        cursor: pointer;
      }
      #debugModal {
        bottom: 20px;
        right: 20px;
        width: 300px;
        max-height: 300px;
        background: rgba(255, 255, 255, 0.95);
        overflow: auto;
        border-radius: 5px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        display: none;
        position: fixed;
      }

      /* ------ Botões e Seletores ------ */
      button,
      .agentSelector {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        border: none;
        padding: 8px;
        margin: 5px 0;
        border-radius: 4px;
        cursor: pointer;
        transition: 0.2s;
      }
      button:hover,
      .agentSelector:hover {
        background: rgba(255, 255, 255, 0.2);
      }
      .agentSelector.selected {
        background: #4caf50;
        font-weight: bold;
      }
      select {
        width: 100%;
        margin: 5px 0;
      }

      /* ------ Ocultamos as imagens carregadas ------ */
      #humanImage,
      #carImage,
      #boatImage,
      #groundImage,
      #waterImage,
      #roadImage,
      #bridgeImage {
        display: none;
      }
    </style>
  </head>

  <body>
    <!-- Imagens dos agentes e terrenos -->
    <img id="humanImage" src="../../static/human.png" />
    <img id="carImage" src="../../static/car.png" />
    <img id="boatImage" src="../../static/boat.png" />
    <img id="groundImage" src="../../static/ground.png" />
    <img id="waterImage" src="../../static/water.png" />
    <img id="roadImage" src="../../static/road.png" />
    <img id="bridgeImage" src="../../static/bridge.png" />

    <!-- Status e Painéis -->
    <div id="gameStatus">
      <span id="debugStatus">Debug: Inativo</span> |
      <span id="pauseStatus">Jogo: Executando</span>
    </div>

    <div id="controls">
      <h4>Controles</h4>
      <button onclick="toggleDebug()">Toggle Debug</button>
      <button onclick="openDebugModal()">Open Debug Modal</button>
      <button onclick="togglePause()">Toggle Pause</button>
      <h4>Algoritmo</h4>
      <select id="pathfindingMethod">
        <option value="A*">A*</option>
        <option value="BFS">BFS</option>
        <option value="Dijkstra">Dijkstra</option>
        <option value="DFS">DFS</option>
      </select>
      <h4>Agentes</h4>
      <div id="agentList"></div>
    </div>

    <div id="howToPlay">
      <h4>Como Jogar</h4>
      <ol>
        <li>Selecione um agente</li>
        <li>Clique no mapa para definir destino</li>
        <li>Use os botões para mudar algoritmo, pausar ou ativar debug</li>
      </ol>
    </div>

    <div id="layerLegend">
      <h4>Custos do Agente</h4>
      <!-- Conteúdo dinâmico conforme seleção do agente -->
    </div>

    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <canvas id="debugCanvas"></canvas>
    </div>

    <!-- Modal de Debug -->
    <div id="debugModal" class="modal">
      <div class="modal-content">
        <span class="close" onclick="closeDebugModal()">&times;</span>
        <pre id="debugLog"></pre>
      </div>
    </div>

    <!-- ------------------------------------------
         Script principal (módulo e lógica)
    ------------------------------------------- -->
    <script type="module">
      import { NavMesh } from "../../src/navmesh/NavMesh.js";
      import { DebugVisualizer } from "../../src/pathfinding/DebugVisualizer.js";
      import { AgentProfile } from "../../src/pathfinding/AgentManager.js";
      import { Pathfinder } from "../../src/pathfinding/Pathfinder.js";
      import { Polygon } from "../../src/navmesh/Polygon.js";

      // Pré-carrega imagens para evitar flicker
      function preloadImages(ids) {
        return new Promise((resolve) => {
          let loaded = 0;
          ids.forEach((id) => {
            const img = document.getElementById(id);
            if (img.complete) {
              if (++loaded === ids.length) resolve();
            } else {
              img.onload = () => {
                if (++loaded === ids.length) resolve();
              };
            }
          });
        });
      }

      // Classe principal do jogo
      class Game {
        constructor() {
          this.canvas = document.getElementById("gameCanvas");
          this.debugCanvas = document.getElementById("debugCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.debugCtx = this.debugCanvas.getContext("2d");
          this.paused = false;
          this.selectedAgentIndex = 0;

          this.setupCanvases();
          this.initNavMesh();
          this.setupEvents();
          this.startGameLoop();
        }

        setupCanvases() {
          const w = window.innerWidth,
            h = window.innerHeight;
          [this.canvas, this.debugCanvas].forEach((c) => {
            c.width = w;
            c.height = h;
          });
        }

        initNavMesh() {
          this.navMesh = new NavMesh(true);
          this.debug = new DebugVisualizer(this.debugCtx, this.navMesh);

          // Registra 4 camadas básicas
          const ls = this.navMesh.layerSystem;
          ls.registerLayer("ground", {
            color: "#4a4a4a",
            imageId: "groundImage",
          });
          ls.registerLayer("water", {
            color: "#006994",
            imageId: "waterImage",
          });
          ls.registerLayer("road", { color: "#505050", imageId: "roadImage" });
          ls.registerLayer("bridge", {
            color: "#8b4513",
            imageId: "bridgeImage",
          });

          // Cria grid 6x6
          this.createGridGeometry(6, 6);
          this.navMesh.buildGraphConsideringObstacles();

          // Array de agentes
          this.agents = [];
          this.createAgent("human", { x: 50, y: 50 });
          this.createAgent("car", { x: 300, y: 300 });
          this.createAgent("boat", { x: 500, y: 100 });

          // Debug visual ativo
          this.debug.toggle(true);
          this.updateUI();
        }

        /**
         * Cria uma grade (cols x rows), cada célula é um Polygon com layer aleatória.
         */
        createGridGeometry(cols, rows) {
          const w = this.canvas.width,
            h = this.canvas.height;
          const cellW = w / cols,
            cellH = h / rows;
          const layers = ["ground", "water", "road", "bridge"];
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              let x1 = c * cellW,
                y1 = r * cellH,
                x2 = x1 + cellW,
                y2 = y1 + cellH;
              let layer = layers[Math.floor(Math.random() * layers.length)];
              let poly = new Polygon(
                [
                  { x: x1, y: y1 },
                  { x: x2, y: y1 },
                  { x: x2, y: y2 },
                  { x: x1, y: y2 },
                ],
                { layer }
              );
              this.navMesh.addPolygon(poly);
            }
          }
        }

        /**
         * Cria um agente com custos específicos por layer e gera um grafo customizado.
         */
        createAgent(type, position) {
          let terrainCosts,
            allowedLayers = new Set(["ground", "road", "bridge", "water"]);
          if (type === "boat")
            terrainCosts = { water: 1, ground: 1000, road: 100, bridge: 50 };
          else if (type === "car")
            terrainCosts = { road: 1, bridge: 50, ground: 1000, water: 1000 };
          else terrainCosts = { ground: 1, road: 50, bridge: 100, water: 200 }; // humano

          let radius = type === "car" ? 10 : 5;
          let profile = new AgentProfile({
            allowedLayers,
            radius,
            minPathWidth: radius * 2,
            terrainCosts,
          });
          let agentGraph = this._buildWeightedGraph(terrainCosts);
          let colorMap = { human: "#0f0", car: "#f00", boat: "#00f" };

          let agent = {
            type,
            position,
            target: null,
            path: [],
            profile,
            graph: agentGraph,
            markerColor: colorMap[type] || "#fff",
            update() {
              if (!this.path.length) return;
              let nx = this.path[0].x,
                ny = this.path[0].y;
              let dx = nx - this.position.x,
                dy = ny - this.position.y;
              let dist = Math.hypot(dx, dy),
                step = 2;
              if (dist <= step) {
                this.position.x = nx;
                this.position.y = ny;
                this.path.shift();
                if (!this.path.length) this.target = null;
              } else {
                this.position.x += (dx / dist) * step;
                this.position.y += (dy / dist) * step;
              }
            },
            draw(ctx) {
              let imgId =
                type === "human"
                  ? "humanImage"
                  : type === "car"
                  ? "carImage"
                  : "boatImage";
              let img = document.getElementById(imgId);
              let [w, h] =
                type === "car"
                  ? [40, 20]
                  : type === "boat"
                  ? [50, 25]
                  : [30, 30];
              if (img) {
                ctx.drawImage(
                  img,
                  this.position.x - w / 2,
                  this.position.y - h / 2,
                  w,
                  h
                );
              } else {
                ctx.fillStyle = this.markerColor;
                ctx.beginPath();
                ctx.arc(
                  this.position.x,
                  this.position.y,
                  w / 2,
                  0,
                  Math.PI * 2
                );
                ctx.fill();
              }
              // destino
              if (this.target) {
                ctx.beginPath();
                ctx.strokeStyle = this.markerColor;
                ctx.arc(this.target.x, this.target.y, 8, 0, 2 * Math.PI);
                ctx.stroke();
              }
            },
          };

          this.agents.push(agent);
          this.updateUI(); // atualiza lista e legenda
        }

        /** Clona o grafo-base e ajusta pesos de acordo com terrainCosts. */
        _buildWeightedGraph(terrainCosts) {
          let base = this.navMesh.graph.clone();
          base.adjList.forEach((edges, nodeId) => {
            edges.forEach((edge) => {
              let A = base.getNode(nodeId).polygon,
                B = base.getNode(edge.nodeId).polygon;
              let costA = terrainCosts[A.layer] || 9999;
              let costB = terrainCosts[B.layer] || 9999;
              edge.peso *= (costA + costB) / 2;
            });
          });
          return base;
        }

        /**
         * Loop principal do jogo: desenha terrenos e agentes (se não estiver pausado).
         */
        startGameLoop() {
          const loop = () => {
            if (!this.paused) {
              this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

              // Desenha cada polígono (terreno)
              this.navMesh.polygons.forEach((poly) => {
                let lc = this.navMesh.layerSystem.layerFilters.get(poly.layer);
                let pat = null;
                if (lc && lc.imageId) {
                  let tex = document.getElementById(lc.imageId);
                  if (tex && tex.complete)
                    pat = this.ctx.createPattern(tex, "repeat");
                }
                this.ctx.fillStyle = pat || (lc ? lc.color : "#000");
                this.ctx.beginPath();
                poly.vertices.forEach((v, i) => {
                  if (i === 0) this.ctx.moveTo(v.x, v.y);
                  else this.ctx.lineTo(v.x, v.y);
                });
                this.ctx.closePath();
                this.ctx.fill();
              });

              // Atualiza e desenha agentes
              this.agents.forEach((agent) => {
                agent.update();
                agent.draw(this.ctx);
              });
            }
            requestAnimationFrame(loop);
          };
          loop();
        }

        /** Eventos de redimensionamento e clique para definir destino do agente. */
        setupEvents() {
          window.addEventListener("resize", () => this.setupCanvases());
          this.canvas.addEventListener("click", (e) => {
            let rect = this.canvas.getBoundingClientRect();
            let target = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            let agent = this.agents[this.selectedAgentIndex];
            let method = document.getElementById("pathfindingMethod").value;
            let res = Pathfinder.findPath({
              graph: agent.graph,
              start: agent.position,
              end: target,
              method,
              partialPath: true,
            });
            if (res.points.length) {
              // Garante que o último ponto seja o destino exato
              let last = res.points[res.points.length - 1];
              if (last.x !== target.x || last.y !== target.y)
                res.points.push(target);
              agent.path = res.points;
            } else {
              agent.path = [target];
            }
            agent.target = target;
          });
        }

        /** Atualiza UI: lista de agentes e legenda com custos do agente selecionado. */
        updateUI() {
          // Debug/Pause
          document.getElementById("debugStatus").textContent =
            "Debug: " + (this.debug.config.enabled ? "Ativo" : "Inativo");
          document.getElementById("pauseStatus").textContent =
            "Jogo: " + (this.paused ? "Pausado" : "Executando");

          // Lista de agentes
          let agentList = document.getElementById("agentList");
          agentList.innerHTML = this.agents
            .map(
              (agent, i) => `
            <div class="agentSelector ${
              i === this.selectedAgentIndex ? "selected" : ""
            }" data-idx="${i}">
              ${agent.type} #${i + 1}
            </div>
          `
            )
            .join("");
          agentList.querySelectorAll(".agentSelector").forEach((el) => {
            el.addEventListener("click", () => {
              this.selectedAgentIndex = parseInt(el.dataset.idx);
              this.updateUI();
            });
          });

          // Legenda (custos do agente selecionado)
          let legend = document.getElementById("layerLegend");
          let sel = this.agents[this.selectedAgentIndex];
          legend.innerHTML = `<h4>Custos ${sel.type}</h4>`;
          Object.entries(sel.profile.terrainCosts).forEach(([layer, cost]) => {
            legend.innerHTML += `<div>${layer} → ${cost}</div>`;
          });
        }
        openDebugModal() {
          let modal = document.getElementById("debugModal");
          let log = document.getElementById("debugLog");
          log.textContent = JSON.stringify(
            this.debug.captureDebugData(),
            null,
            2
          );
          modal.style.display = "block";
        }
        // Alterna debug e exibe modal
        toggleDebug() {
          this.debug.toggle(!this.debug.config.enabled);
          document.getElementById("debugStatus").textContent =
            "Debug: " + (this.debug.config.enabled ? "Ativo" : "Inativo");
        }

        /** Abre a modal de debug exibindo os logs atuais. */

        // Pausa ou retoma o loop
        togglePause() {
          this.paused = !this.paused;
          document.getElementById("pauseStatus").textContent =
            "Jogo: " + (this.paused ? "Pausado" : "Executando");
        }
      }

      // Inicia tudo após carregar imagens
      window.addEventListener("load", async () => {
        await preloadImages([
          "groundImage",
          "waterImage",
          "roadImage",
          "bridgeImage",
          "humanImage",
          "carImage",
          "boatImage",
        ]);
        const game = new Game();
        window.game = game;
        window.toggleDebug = () => game.toggleDebug();
        window.togglePause = () => game.togglePause();
        window.openDebugModal = () => game.openDebugModal();
      });
      window.closeDebugModal = () =>
        (document.getElementById("debugModal").style.display = "none");
    </script>
  </body>
</html>
