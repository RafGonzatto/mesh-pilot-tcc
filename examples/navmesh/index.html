<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>NavMesh Demo Game</title>
    <style>
      /* ------ Layout Básico ------ */
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      }
      #gameCanvas {
        background: #1a1a1a
          url('data:image/svg+xml;utf8,<svg width="40" height="40" xmlns="http://www.w3.org/2000/svg"><rect width="40" height="40" fill="%23222222"/><path d="M40 0 L0 0 0 40" fill="none" stroke="%232a2a2a" stroke-width="1"/></svg>');
      }
      #debugCanvas {
        pointer-events: none;
      }
      /* ------ Contêineres fixos ------ */
      #controls,
      #howToPlay,
      #layerLegend,
      #gameStatus {
        position: fixed;
        padding: 10px;
        background: rgba(25, 25, 25, 0.95);
        color: #fff;
        border-radius: 5px;
        z-index: 1000;
      }
      #controls {
        top: 20px;
        left: 20px;
        width: 220px;
      }
      #howToPlay {
        top: 20px;
        right: 20px;
        max-width: 280px;
      }
      #layerLegend {
        bottom: 20px;
        left: 20px;
        min-width: 150px;
      }
      #gameStatus {
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        z-index: 1001;
        font-size: 0.9em;
      }
      /* ------ Modal de Debug ------ */
      .modal {
        display: none;
        position: fixed;
        z-index: 2000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }
      .modal-content {
        background: #fff;
        margin: 10% auto;
        padding: 20px;
        width: 80%;
        max-width: 600px;
        color: #000;
        border-radius: 5px;
      }
      .close {
        float: right;
        font-size: 24px;
        cursor: pointer;
      }
      #debugModal {
        bottom: 20px;
        right: 20px;
        width: 300px;
        max-height: 300px;
        background: rgba(255, 255, 255, 0.95);
        overflow: auto;
        border-radius: 5px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        display: none;
        position: fixed;
      }
      /* ------ Botões e Seletores ------ */
      button,
      .agentSelector {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        border: none;
        padding: 8px;
        margin: 5px 0;
        border-radius: 4px;
        cursor: pointer;
        transition: 0.2s;
      }
      button:hover,
      .agentSelector:hover {
        background: rgba(255, 255, 255, 0.2);
      }
      .agentSelector.selected {
        background: #4caf50;
        font-weight: bold;
      }
      select {
        width: 100%;
        margin: 5px 0;
      }
      /* ------ Ocultamos as imagens carregadas ------ */
      #humanImage,
      #carImage,
      #boatImage,
      #groundImage,
      #waterImage,
      #roadImage,
      #bridgeImage,
      #obstacleImage {
        display: none;
      }
    </style>
  </head>
  <body>
    <!-- Imagens dos agentes, terrenos e obstáculo -->
    <img id="obstacleImage" src="../../static/obstacle.png" />
    <img id="humanImage" src="../../static/human.png" />
    <img id="carImage" src="../../static/car.png" />
    <img id="boatImage" src="../../static/boat.png" />
    <img id="groundImage" src="../../static/ground.png" />
    <img id="waterImage" src="../../static/water.png" />
    <img id="roadImage" src="../../static/road.png" />
    <img id="bridgeImage" src="../../static/bridge.png" />

    <!-- Status e Painéis -->
    <div id="gameStatus">
      <span id="debugStatus">Debug: Inativo</span> |
      <span id="pauseStatus">Jogo: Executando</span>
    </div>
    <div id="controls">
      <h4>Controles</h4>
      <button onclick="toggleDebug()">Toggle Debug</button>
      <button onclick="openDebugModal()">Open Debug Modal</button>
      <button onclick="togglePause()">Toggle Pause</button>
      <h4>Algoritmo</h4>
      <select id="pathfindingMethod">
        <option value="A*">A*</option>
        <option value="BFS">BFS</option>
        <option value="Dijkstra">Dijkstra</option>
        <option value="DFS">DFS</option>
      </select>
      <h4>Agentes</h4>
      <div id="agentList"></div>
    </div>
    <div id="howToPlay">
      <h4>Como Jogar</h4>
      <ol>
        <li>Selecione um agente na lista</li>
        <li>Clique no mapa para definir destino</li>
        <li>Duplo clique para adicionar obstáculo (modo de edição)</li>
      </ol>
    </div>
    <div id="layerLegend">
      <h4>Custos do Agente</h4>
      <!-- Conteúdo dinâmico -->
    </div>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <canvas id="debugCanvas"></canvas>
    </div>
    <div id="debugModal" class="modal">
      <div class="modal-content">
        <span class="close" onclick="closeDebugModal()">&times;</span>
        <pre id="debugLog"></pre>
      </div>
    </div>

    <script type="module">
      import { NavMesh } from "../../src/navmesh/NavMesh.js";
      import { DebugVisualizer } from "../../src/pathfinding/DebugVisualizer.js";
      import { AgentProfile } from "../../src/pathfinding/AgentManager.js";
      import { Pathfinder } from "../../src/pathfinding/Pathfinder.js";
      import { Polygon } from "../../src/navmesh/Polygon.js";
      import { AgentManager } from "../../src/pathfinding/AgentManager.js";
      function safeStringify(obj, space = 2) {
        const seen = new WeakSet();
        return JSON.stringify(
          obj,
          (key, value) => {
            if (typeof value === "object" && value !== null) {
              if (seen.has(value)) return;
              seen.add(value);
            }
            return value;
          },
          space
        );
      }

      function formatDebugData(data) {
        let html = '<div class="debug-summary">';
        html += `<p><strong>Polygons:</strong> ${data.polygons}</p>`;
        html += `<p><strong>Nodes:</strong> ${data.nodes}</p>`;
        html += `<p><strong>Obstacles:</strong> ${data.obstacles}</p>`;
        if (data.spatialGrid) {
          html += `<p><strong>Spatial Grid:</strong> cellSize: ${data.spatialGrid.cellSize}, cells: ${data.spatialGrid.cells}</p>`;
        }
        html += "</div>";

        if (data.agentPaths && data.agentPaths.length) {
          html += "<h4>Agent Paths:</h4><ul>";
          data.agentPaths.forEach((agent) => {
            html += `<li><strong>${agent.id} (${agent.type})</strong>: ${agent.currentPath.length} nodes</li>`;
          });
          html += "</ul>";
        }

        html +=
          "<h4>Configuração:</h4><pre>" + safeStringify(data.config) + "</pre>";
        return html;
      }

      // Função para pré-carregar imagens
      function preloadImages(ids) {
        return new Promise((resolve) => {
          let loaded = 0;
          ids.forEach((id) => {
            const img = document.getElementById(id);
            if (img.complete) {
              if (++loaded === ids.length) resolve();
            } else {
              img.onload = () => {
                if (++loaded === ids.length) resolve();
              };
            }
          });
        });
      }

      class Game {
        constructor() {
          this.canvas = document.getElementById("gameCanvas");
          this.debugCanvas = document.getElementById("debugCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.debugCtx = this.debugCanvas.getContext("2d");
          this.paused = false;
          // Define o agente selecionado inicialmente (ID)
          this.selectedAgentId = "agent1";
          this.setupCanvases();
          this.initNavMesh();
          this.setupEvents();
          this.startGameLoop();
        }

        drawAgent(agent) {
          const imgId = `${agent.type}Image`; // Ex: "humanImage"
          const img = document.getElementById(imgId);
          if (img && img.complete) {
            const size = 32;
            this.ctx.drawImage(
              img,
              agent.position.x - size / 2,
              agent.position.y - size / 2,
              size,
              size
            );
          } else {
            // Fallback com círculo
            this.ctx.fillStyle = "#ff0000";
            this.ctx.beginPath();
            this.ctx.arc(
              agent.position.x,
              agent.position.y,
              10,
              0,
              Math.PI * 2
            );
            this.ctx.fill();
          }
        }

        setupCanvases() {
          const w = window.innerWidth,
            h = window.innerHeight;
          [this.canvas, this.debugCanvas].forEach((c) => {
            c.width = w;
            c.height = h;
          });
        }

        initNavMesh() {
          // Instancia o NavMesh e ativa obstáculos dinâmicos
          this.navMesh = new NavMesh(true);
          this.navMesh.enableDynamicObstacles({
            cellSize: 80,
            autoUpdate: true,
            obstacleLayer: "dynamic",
          });

          // Registra as camadas
          const ls = this.navMesh.layerSystem;
          ls.registerLayer("dynamic", { color: "rgba(255, 0, 0, 0.5)" });
          ls.registerLayer("ground", {
            color: "#4a4a4a",
            imageId: "groundImage",
          });
          ls.registerLayer("water", {
            color: "#006994",
            imageId: "waterImage",
          });
          ls.registerLayer("road", { color: "#505050", imageId: "roadImage" });
          ls.registerLayer("bridge", {
            color: "#8b4513",
            imageId: "bridgeImage",
          });

          // Cria uma malha com subdivisão maior para maior precisão
          this.createGridGeometry(20, 20);
          this.navMesh.buildGraphConsideringObstacles(
            this.navMesh.dynamicObstacleManager.obstacles
          );
          // Cria o DebugVisualizer
          this.debug = new DebugVisualizer(this.debugCtx, this.navMesh, {
            debugEventLog: true,
            showLabels: true,
            showSpatialGrid: true,
          });
          this.debug.toggle(true);

          // Cria o AgentManager e registra perfis para cada tipo de agente
          this.agentManager = new AgentManager(this.navMesh);
          this.agentManager.registerProfile(
            "human",
            new AgentProfile({
              radius: 5,
              minPathWidth: 10,
              maxSlope: 45,
              allowedLayers: new Set(["water", "ground", "road", "bridge"]),
              terrainCosts: { water: 1000, ground: 1, road: 50, bridge: 100 },
            })
          );
          this.agentManager.registerProfile(
            "car",
            new AgentProfile({
              radius: 10,
              minPathWidth: 20,
              maxSlope: 45,
              allowedLayers: new Set(["water", "ground", "road", "bridge"]),
              terrainCosts: { road: 1, bridge: 50, ground: 1000, water: 1000 },
            })
          );
          this.agentManager.registerProfile(
            "boat",
            new AgentProfile({
              radius: 5,
              minPathWidth: 10,
              maxSlope: 45,
              allowedLayers: new Set(["water", "ground", "road", "bridge"]),
              terrainCosts: { water: 1, ground: 1000, road: 100, bridge: 50 },
            })
          );

          // Cria os agentes via AgentManager – agora com o 4º parâmetro 'type'

          this.agentManager.createAgent("agent1", "human", { x: 50, y: 50 });
          this.agentManager.createAgent("agent2", "car", { x: 300, y: 300 });
          this.agentManager.createAgent("agent3", "boat", { x: 500, y: 100 });

          // Atualiza a interface (lista de agentes)
          this.updateUI();
          console.log("Agentes criados:", this.agentManager.activeAgents.size);
        }

        createGridGeometry(cols, rows) {
          const w = this.canvas.width,
            h = this.canvas.height;
          const cellW = w / cols,
            cellH = h / rows;
          const layers = ["ground", "water", "road", "bridge"];
          this.grid = [];
          for (let r = 0; r < rows; r++) {
            this.grid[r] = [];
            for (let c = 0; c < cols; c++) {
              // Arredonda para evitar imprecisão de ponto flutuante
              const x1 = Math.round(c * cellW),
                y1 = Math.round(r * cellH),
                x2 = Math.round((c + 1) * cellW),
                y2 = Math.round((r + 1) * cellH);
              const poly = new Polygon(
                [
                  { x: x1, y: y1 },
                  { x: x2, y: y1 },
                  { x: x2, y: y2 },
                  { x: x1, y: y2 },
                ],
                { layer: layers[Math.floor(Math.random() * layers.length)] }
              );
              this.navMesh.addPolygon(poly);
              this.grid[r][c] = poly;
            }
          }
          // Conecta os polígonos adjacentes
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const current = this.grid[r][c];
              if (c < cols - 1)
                this.connectPolygons(current, this.grid[r][c + 1]);
              if (r < rows - 1)
                this.connectPolygons(current, this.grid[r + 1][c]);
            }
          }
        }
        connectPolygons(polyA, polyB) {
          polyA.neighbors = polyA.neighbors || [];
          polyB.neighbors = polyB.neighbors || [];
          polyA.neighbors.push(polyB);
          polyB.neighbors.push(polyA);
        }

        setupEvents() {
          window.addEventListener("resize", () => this.setupCanvases());
          this.canvas.addEventListener("click", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const target = {
              x: e.clientX - rect.left,
              y: e.clientY - rect.top,
            };
            if (this.editorMode) {
              this.addObstacleAt(target.x, target.y);
              return;
            }
            // Define destino para o agente atualmente selecionado
            this.agentManager.setAgentTarget(
              this.selectedAgentId,
              target,
              true
            );
          });
          this.canvas.addEventListener("dblclick", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left,
              y = e.clientY - rect.top;
            this.addObstacleAt(x, y);
          });
          // Permite selecionar agente pela lista
          document
            .getElementById("agentList")
            .addEventListener("click", (e) => {
              if (e.target && e.target.dataset && e.target.dataset.id) {
                this.selectedAgentId = e.target.dataset.id;
                this.updateUI();
              }
            });
        }

        addObstacleAt(x, y) {
          const size = 100;
          const obstacle = new Polygon(
            [
              { x: x - size / 2, y: y - size / 2 },
              { x: x + size / 2, y: y - size / 2 },
              { x: x + size / 2, y: y + size / 2 },
              { x: x - size / 2, y: y + size / 2 },
            ],
            {
              layer: "dynamic",
              metadata: {
                imageId: "obstacleImage",
                width: 64,
                height: 64,
                walkable: false,
              },
            }
          );
          this.navMesh.addPolygon(obstacle);
          this.navMesh.dynamicObstacleManager.addObstacle(obstacle);

          // Passando todos os obstáculos do dynamicObstacleManager
          const allObs = Array.from(
            this.navMesh.dynamicObstacleManager.obstacles.values()
          );
          this.navMesh.buildGraphConsideringObstacles(allObs);
        }

        startGameLoop() {
          const loop = () => {
            if (!this.paused) {
              this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
              this.navMesh.polygons.forEach((poly) => {
                if (poly.layer === "dynamic" && poly.metadata?.imageId) {
                  const img = document.getElementById(poly.metadata.imageId);
                  if (img && img.complete) {
                    const center = poly.getCenter();
                    const w = poly.metadata.width || 50;
                    const h = poly.metadata.height || 50;
                    this.ctx.drawImage(
                      img,
                      center.x - w / 2,
                      center.y - h / 2,
                      w,
                      h
                    );
                  } else {
                    this._fillPolygon(poly);
                  }
                } else {
                  this._fillPolygon(poly);
                }
              });
              this.agentManager.activeAgents.forEach((agent) => {
                this.agentManager.updateAgent(agent.id, 2);
                this.drawAgent(agent);
              });
            }
            requestAnimationFrame(loop);
          };
          loop();
        }

        _fillPolygon(poly) {
          const lc = this.navMesh.layerSystem.layerFilters.get(poly.layer);
          let pat = null;
          if (lc && lc.imageId) {
            const tex = document.getElementById(lc.imageId);
            if (tex && tex.complete) {
              pat = this.ctx.createPattern(tex, "repeat");
            }
          }
          this.ctx.fillStyle = pat || (lc ? lc.color : "#000");
          this.ctx.beginPath();
          poly.vertices.forEach((v, i) => {
            if (i === 0) this.ctx.moveTo(v.x, v.y);
            else this.ctx.lineTo(v.x, v.y);
          });
          this.ctx.closePath();
          this.ctx.fill();
        }

        updateUI() {
          document.getElementById("debugStatus").textContent =
            "Debug: " + (this.debug.config.enabled ? "Ativo" : "Inativo");
          document.getElementById("pauseStatus").textContent =
            "Jogo: " + (this.paused ? "Pausado" : "Executando");

          // Atualiza a lista de agentes com destaque para o selecionado
          const agentListEl = document.getElementById("agentList");
          let html = "";
          this.agentManager.activeAgents.forEach((agent) => {
            const cls =
              agent.id === this.selectedAgentId
                ? "agentSelector selected"
                : "agentSelector";
            html += `<div class="${cls}" data-id="${agent.id}">
                      ${agent.type} (${agent.id})
                     </div>`;
          });
          agentListEl.innerHTML = html;

          // Busca o agente selecionado usando .values() (caso activeAgents seja um Map)
          const agent = Array.from(
            this.agentManager.activeAgents.values()
          ).find((a) => a.id === this.selectedAgentId);
          let costHtml = "";
          if (agent) {
            const profile = this.agentManager.agentProfiles.get(agent.type);
            if (profile && profile.terrainCosts) {
              for (const terrain in profile.terrainCosts) {
                costHtml += `<div>${terrain}: ${profile.terrainCosts[terrain]}</div>`;
              }
            }
          }
          document.getElementById(
            "layerLegend"
          ).innerHTML = `<h4>Custos do Agente</h4>${costHtml}`;
        }
        toggleEditorMode() {
          this.editorMode = !this.editorMode;
          document.getElementById("modeLabel").textContent = this.editorMode
            ? "ON"
            : "OFF";
        }

        toggleDebug() {
          this.debug.toggle(!this.debug.config.enabled);
          document.getElementById("debugStatus").textContent =
            "Debug: " + (this.debug.config.enabled ? "Ativo" : "Inativo");
        }

        togglePause() {
          this.paused = !this.paused;
          document.getElementById("pauseStatus").textContent =
            "Jogo: " + (this.paused ? "Pausado" : "Executando");
        }

        openDebugModal() {
          const modal = document.getElementById("debugModal");
          const log = document.getElementById("debugLog");
          const updateModal = () => {
            const debugData = this.debug.captureDebugData();
            log.innerHTML = formatDebugData(debugData);
          };
          updateModal(); // Atualiza imediatamente
          // Inicia um intervalo para atualizar a cada 1 segundo (ou ajuste conforme necessário)
          this._debugModalInterval = setInterval(updateModal, 1000);
          modal.style.display = "block";
        }

        closeDebugModal() {
          const modal = document.getElementById("debugModal");
          clearInterval(this._debugModalInterval);
          modal.style.display = "none";
        }
      }

      window.addEventListener("load", async () => {
        await preloadImages([
          "groundImage",
          "waterImage",
          "roadImage",
          "bridgeImage",
          "humanImage",
          "carImage",
          "boatImage",
          "obstacleImage",
        ]);
        const game = new Game();
        window.game = game;
        window.toggleEditorMode = () => game.toggleEditorMode();
        window.toggleDebug = () => game.toggleDebug();
        window.togglePause = () => game.togglePause();
        window.openDebugModal = () => game.openDebugModal();
      });
      window.closeDebugModal = () => {
        document.getElementById("debugModal").style.display = "none";
      };
    </script>
  </body>
</html>
