<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <title>Jogo Complexo - Pathfinding com NavMesh e A*</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden; /* Para não ter barras de rolagem */
      }
      #gameCanvas {
        display: block;
        background: #f0f0f0;
        border: 1px solid #ccc;
        margin: 0 auto; /* centralizar horizontalmente se quiser */
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.85);
        padding: 8px;
        font-family: sans-serif;
        border-radius: 4px;
        width: 220px;
      }
      #info h3 {
        margin-top: 0;
      }
      button {
        margin: 4px 0;
      }
      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 20px 30px;
        font-family: sans-serif;
        font-size: 24px;
        display: none; /* só aparece quando perder */
        border-radius: 8px;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <h3>Jogo de Perseguição (Pathfinding)</h3>
      <p>
        Controle o <strong>jogador</strong> pelas setas do teclado.<br />
        O <strong>inimigo</strong> usará o NavMesh e o A* para perseguí-lo,
        navegando somente pelos polígonos.
      </p>
      <p><strong>Sobreviva</strong> o máximo que puder!</p>
      <p>Tempo vivo: <span id="timeAlive">0.0</span> seg</p>
    </div>

    <div id="gameOver">
      <p>Você foi pego!</p>
      <p id="scoreMsg"></p>
      <p>O jogo reiniciará em breve...</p>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script type="module">
      /**
       * IMPORTAÇÃO DA BIBLIOTECA
       * Ajuste o caminho conforme a estrutura de pastas do seu projeto.
       * Este exemplo supõe que a biblioteca está em '../../src/index.js'
       * e que a pasta 'examples' está no mesmo nível de 'src'.
       */
      import { NavMesh, Polygon, AStar } from "../../src/index.js";

      /***************************************************
       *  VARIÁVEIS GLOBAIS E CONSTANTES
       ***************************************************/
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      const WIDTH = canvas.width;
      const HEIGHT = canvas.height;

      // Exibição de tempo vivo
      const timeAliveEl = document.getElementById("timeAlive");
      const gameOverScreen = document.getElementById("gameOver");
      const scoreMsg = document.getElementById("scoreMsg");

      // Polígonos (regiões onde o inimigo pode caminhar)
      let polygons = [];
      let navMesh = null;
      let pathfinder = null;

      // Jogador (controlado via teclado)
      const player = {
        x: 100,
        y: 100,
        radius: 10,
        speed: 200, // pixels por segundo
        vx: 0, // velocity x
        vy: 0, // velocity y
      };

      // Inimigo (controlado via pathfinding)
      const enemy = {
        x: 600,
        y: 400,
        radius: 10,
        moveSpeed: 140, // pixels por segundo
        path: [],
        pathIndex: 0,
      };

      // Variáveis de controle do loop
      let lastTime = 0;
      let timeAlive = 0;
      let isGameOver = false;
      let pathCalcTimer = 0; // controla de quanto em quanto tempo o inimigo recalcula o caminho

      /***************************************************
       *  CONFIGURAÇÃO DO JOGO
       ***************************************************/

      /**
       * Cria vários polígonos para ilustrar regiões “navegáveis” e obstáculos.
       * O inimigo só se move dentro dessas regiões.
       */
      function createPolygons() {
        polygons = [];

        // Polígono grande na parte superior esquerda
        polygons.push(
          new Polygon([
            { x: 0, y: 0 },
            { x: 350, y: 0 },
            { x: 350, y: 250 },
            { x: 0, y: 250 },
          ])
        );

        // Polígono grande na parte inferior direita
        polygons.push(
          new Polygon([
            { x: 200, y: 200 },
            { x: 800, y: 200 },
            { x: 800, y: 600 },
            { x: 200, y: 600 },
          ])
        );

        // Pequeno polígono no centro - obstáculo ou “ilha”
        polygons.push(
          new Polygon([
            { x: 370, y: 220 },
            { x: 420, y: 220 },
            { x: 420, y: 270 },
            { x: 370, y: 270 },
          ])
        );

        // Polígono irregular
        polygons.push(
          new Polygon([
            { x: 100, y: 300 },
            { x: 140, y: 330 },
            { x: 150, y: 380 },
            { x: 90, y: 370 },
          ])
        );
      }

      /**
       * Cria e configura o NavMesh para os polígonos.
       */
      function buildNavMesh() {
        navMesh = new NavMesh();
        polygons.forEach((poly) => navMesh.addPolygon(poly));
        navMesh.buildGraph(); // Constrói o grafo
        pathfinder = new AStar();
      }

      /***************************************************
       *  LÓGICA DE PATHFINDING - INIMIGO
       ***************************************************/

      /**
       * Inimigo recalcula o caminho até o jogador usando A* no NavMesh.
       * Se não encontrar caminho, enemy.path ficará vazio.
       */
      function recalcEnemyPath() {
        if (!navMesh || !pathfinder) return;

        // Posição-alvo é a do player
        const targetPos = { x: player.x, y: player.y };
        // Início é a posição atual do inimigo
        const startPos = { x: enemy.x, y: enemy.y };

        const newPath = pathfinder.findPath(startPos, targetPos, navMesh.graph);

        if (newPath.length > 0) {
          enemy.path = newPath;
          enemy.pathIndex = 0;
        } else {
          enemy.path = [];
          enemy.pathIndex = 0;
        }
      }

      /**
       * Move o inimigo ao longo do caminho.
       */
      function updateEnemy(deltaTime) {
        if (enemy.path.length === 0) return; // sem caminho

        const waypoint = enemy.path[enemy.pathIndex];
        const dx = waypoint.x - enemy.x;
        const dy = waypoint.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 1) {
          // Move em direção ao waypoint
          const vx = (dx / dist) * enemy.moveSpeed;
          const vy = (dy / dist) * enemy.moveSpeed;
          enemy.x += vx * deltaTime;
          enemy.y += vy * deltaTime;
        } else {
          // Chegou no waypoint, vai para o próximo
          enemy.pathIndex++;
          if (enemy.pathIndex >= enemy.path.length) {
            enemy.pathIndex = enemy.path.length - 1; // fica no fim
          }
        }
      }

      /***************************************************
       *  LÓGICA DO JOGADOR
       ***************************************************/

      /**
       * Atualiza a posição do jogador de acordo com as velocidades (vx, vy).
       */
      function updatePlayer(deltaTime) {
        player.x += player.vx * deltaTime;
        player.y += player.vy * deltaTime;

        // Limites de tela (para não sair do canvas)
        if (player.x < player.radius) player.x = player.radius;
        if (player.x > WIDTH - player.radius) player.x = WIDTH - player.radius;
        if (player.y < player.radius) player.y = player.radius;
        if (player.y > HEIGHT - player.radius)
          player.y = HEIGHT - player.radius;
      }

      /***************************************************
       *  SISTEMA DE CONTROLES (TECLADO)
       ***************************************************/
      window.addEventListener("keydown", (e) => {
        switch (e.key) {
          case "ArrowUp":
          case "w":
            player.vy = -player.speed;
            break;
          case "ArrowDown":
          case "s":
            player.vy = player.speed;
            break;
          case "ArrowLeft":
          case "a":
            player.vx = -player.speed;
            break;
          case "ArrowRight":
          case "d":
            player.vx = player.speed;
            break;
        }
      });

      window.addEventListener("keyup", (e) => {
        switch (e.key) {
          case "ArrowUp":
          case "w":
          case "ArrowDown":
          case "s":
            player.vy = 0;
            break;
          case "ArrowLeft":
          case "a":
          case "ArrowRight":
          case "d":
            player.vx = 0;
            break;
        }
      });

      /***************************************************
       *  DETECÇÃO DE “GAME OVER”
       ***************************************************/

      /**
       * Se o inimigo encosta no jogador, é game over.
       */
      function checkCollision() {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < player.radius + enemy.radius) {
          isGameOver = true;
          showGameOverScreen();
        }
      }

      /**
       * Mostra a mensagem de Game Over e agenda um reinício.
       */
      function showGameOverScreen() {
        scoreMsg.textContent = `Você sobreviveu por ${timeAlive.toFixed(1)}s!`;
        gameOverScreen.style.display = "block";

        // Reinicia o jogo após alguns segundos
        setTimeout(() => {
          gameOverScreen.style.display = "none";
          initGame();
        }, 3000);
      }

      /***************************************************
       *  DESENHO / RENDERIZAÇÃO
       ***************************************************/

      /**
       * Desenha os polígonos no canvas, diferenciando cada um pela cor.
       */
      function drawPolygons() {
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#333";

        navMesh.polygons.forEach((poly, index) => {
          ctx.fillStyle = `rgba(${(60 * index) % 255}, ${
            (100 * index) % 255
          }, ${(180 * index) % 255}, 0.3)`;
          ctx.beginPath();
          ctx.moveTo(poly.vertices[0].x, poly.vertices[0].y);
          for (let i = 1; i < poly.vertices.length; i++) {
            ctx.lineTo(poly.vertices[i].x, poly.vertices[i].y);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        });
      }

      /**
       * Desenha o caminho atual do inimigo, se existir.
       */
      function drawEnemyPath() {
        if (enemy.path.length <= 1) return;

        ctx.lineWidth = 3;
        ctx.strokeStyle = "blue";
        ctx.beginPath();
        ctx.moveTo(enemy.path[0].x, enemy.path[0].y);
        for (let i = 1; i < enemy.path.length; i++) {
          ctx.lineTo(enemy.path[i].x, enemy.path[i].y);
        }
        ctx.stroke();

        // Desenhar waypoints como pequenos círculos
        ctx.fillStyle = "blue";
        enemy.path.forEach((pt) => {
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      /**
       * Desenha o jogador em verde.
       */
      function drawPlayer() {
        ctx.fillStyle = "green";
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
        ctx.fill();
      }

      /**
       * Desenha o inimigo em vermelho.
       */
      function drawEnemy() {
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
        ctx.fill();
      }

      /***************************************************
       *  LOOP PRINCIPAL
       ***************************************************/
      function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        if (isGameOver) {
          // Se perdeu, pausa a lógica de jogo (mas pode manter animação se quiser)
          requestAnimationFrame(gameLoop);
          return;
        }

        // Atualiza tempo vivo
        timeAlive += deltaTime;
        timeAliveEl.textContent = timeAlive.toFixed(1);

        // Atualiza jogador
        updatePlayer(deltaTime);

        // Recalcula o caminho do inimigo a cada 0.5s
        pathCalcTimer += deltaTime;
        if (pathCalcTimer >= 0.5) {
          recalcEnemyPath();
          pathCalcTimer = 0;
        }

        // Move o inimigo ao longo do caminho
        updateEnemy(deltaTime);

        // Verifica colisão
        checkCollision();

        // Desenha cena
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        drawPolygons();
        drawEnemyPath();
        drawPlayer();
        drawEnemy();

        requestAnimationFrame(gameLoop);
      }

      /***************************************************
       *  INICIALIZAÇÃO E REINÍCIO DO JOGO
       ***************************************************/
      function initGame() {
        // Redefine variáveis de estado
        isGameOver = false;
        timeAlive = 0;

        // Define posições iniciais
        player.x = 100;
        player.y = 100;
        player.vx = 0;
        player.vy = 0;

        enemy.x = 600;
        enemy.y = 400;
        enemy.path = [];
        enemy.pathIndex = 0;

        // Recalcula (ou recria) NavMesh se quiser
        // (Neste exemplo, iremos manter os mesmos polígonos)
        // buildNavMesh();

        // Limpa timers
        pathCalcTimer = 0;

        // Inicia o loop
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
      }

      /**
       * Cria todo o cenário e inicia o jogo pela primeira vez.
       */
      function main() {
        // 1) Criar polígonos
        createPolygons();

        // 2) Construir NavMesh
        buildNavMesh();

        // 3) Iniciar jogo
        initGame();
      }

      main();
    </script>
  </body>
</html>
